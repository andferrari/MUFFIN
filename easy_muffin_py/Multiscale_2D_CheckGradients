#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Nov 15 15:21:27 2017

@author: rammanouil
"""


# ==============================================================================
# OPEN PSF AND DIRTY CUBE - SKY to check results
# ==============================================================================

import os
import numpy as np
from astropy.io import fits
from deconv3d_tools import conv
import pylab as pl 

def checkdim(x):
    if len(x.shape) == 4:
        x = np.squeeze(x)
        x = x.transpose((2, 1, 0))
    return x

folder = 'data256Eusipco'
file_in = 'M31_3d_conv_256_10db'

folder = os.path.join(os.getcwd(), folder)
genname = os.path.join(folder, file_in)
psfname = genname+'_psf.fits'
drtname = genname+'_dirty.fits'

CubePSF = np.squeeze(checkdim(fits.getdata(psfname, ext=0))[:,:,0:1])
CubeDirty = np.squeeze(checkdim(fits.getdata(drtname, ext=0))[:,:,0:1])

skyname = genname+'_sky.fits'
sky = checkdim(fits.getdata(skyname, ext=0))
sky = np.squeeze(sky[:,:,0:1])
sky2 = np.sum(sky*sky)

from deconv2d import EasyMuffin, EasyMuffinSURE
from deconv2dMultiscale import EasyMuffin as EasyMuffinm 
from deconv2dMultiscale import EasyMuffinSURE as EasyMuffinSUREm 

#%% Compute real derivative w.r.t. mu1 et mu2 
nb = (2,0)
nitermax = 1000

sigma=10
truesky=sky
psf=CubePSF
dirty=CubeDirty
Noise = CubeDirty - conv(CubePSF,sky)
var = np.sum(Noise**2)/Noise.size
step_mus =0

n1 = 100
n2 = 100
mu_1,mu_2 = np.mgrid[4:9:np.complex(0,n1),0:3:np.complex(0,n2)]
mu1mu2 = np.vstack((mu_1.flatten(),mu_2.flatten())).T

Risk = []
wmse = []
wmsesure = []
wmsesurefdmc = []
sugarfdmc = {}
for counter in range(2):
    sugarfdmc[counter] = []
                  
for mu_s in mu1mu2:
    print(mu_s)
    args = {'mu_s':mu_s,'nb':nb,'truesky':sky,'psf':CubePSF,'dirty':CubeDirty,'var':var,'step_mus':step_mus}
    EMm2= EasyMuffinSUREm(**args)
    EMm2.loop_fdmc(nitermax)
    
    Risk.append(EMm2.costlist[-1])
    wmse.append(EMm2.wmselist[-1])
    wmsesure.append(EMm2.wmselistsure[-1])
    wmsesurefdmc.append(EMm2.wmselistsurefdmc[-1])
    
    for counter in range(2):
        sugarfdmc[counter].append(EMm2.sugarfdmclist[counter][-1])

from mpl_toolkits.mplot3d import axes3d
import matplotlib.pyplot as plt

tmp = np.reshape(wmse,(n1,n2))
fig = plt.figure()
ax = fig.add_subplot(111,projection='3d')
ax.plot_wireframe(mu_1,mu_2,tmp)

for counter in range(2):
    tmp = sugarfdmc[counter][:]
    tmp = np.array(tmp).reshape(n1,n2)
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    # Grab some test data.
    #X, Y, Z = axes3d.get_test_data(0.05)
    # Plot a basic wireframe.
    #ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)
    ax.plot_wireframe(mu_1,mu_2,tmp)

dRisk = np.diff(Risk)/np.diff(mu_s_)








# Grab some test data.
X, Y, Z = axes3d.get_test_data(0.05)

# Plot a basic wireframe.
ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)

plt.show()






